{
    "docs": [
        {
            "location": "/",
            "text": "Node.py v0.0.18 Documentation\n\n\nusage\n:\n \nnodepy\n \n[-\nh\n]\n \n[-\nd\n]\n \n[-\nv\n]\n \n[-\nc\n \nEXPR\n]\n \n[--\ncurrent\n-\ndir\n \nDIR\n]\n \n[--\nversion\n]\n\n              \n[--\nkeep\n-\narg0\n]\n \n[-\nP\n \nPRELOAD\n]\n \n[--\npymain\n]\n\n              \n...\n\n\n\n\n\n\nNode.py is a layer on top of the Python runtime which allows to load other\nmodules the Node.js way, using a [require()][require] function.\n\n\nSynopsis\n\n\nnodepy                (interactive console)\nnodepy -c EXPR [...]  (evaluate EXPR)\nnodepy REQUEST [...]  (resolve REQUEST and execute it)\n\n\n\n\n\nPositional Arguments\n\n\narguments\n\n\n\n\n\nOptional Arguments\n\n\n-h, --help            show this help message and exit\n-d, --debug           Enter the interactive debugger when an exception would cause the application to exit.\n-v, --verbose         Be verbose about what's happening in the Node.py context.\n-c EXPR, --exec EXPR  Evaluate a Python expression.\n--current-dir DIR     Change where the initial request will be resolved in.\n--version             Print the Node.py version and exit.\n--keep-arg0           Do not overwrite sys.argv[0] when executing a file.\n-P PRELOAD, --preload PRELOAD\n--pymain",
            "title": "Home"
        },
        {
            "location": "/#nodepy-v0018-documentation",
            "text": "usage :   nodepy   [- h ]   [- d ]   [- v ]   [- c   EXPR ]   [-- current - dir   DIR ]   [-- version ] \n               [-- keep - arg0 ]   [- P   PRELOAD ]   [-- pymain ] \n               ...   Node.py is a layer on top of the Python runtime which allows to load other\nmodules the Node.js way, using a [require()][require] function.  Synopsis  nodepy                (interactive console)\nnodepy -c EXPR [...]  (evaluate EXPR)\nnodepy REQUEST [...]  (resolve REQUEST and execute it)  Positional Arguments  arguments  Optional Arguments  -h, --help            show this help message and exit\n-d, --debug           Enter the interactive debugger when an exception would cause the application to exit.\n-v, --verbose         Be verbose about what's happening in the Node.py context.\n-c EXPR, --exec EXPR  Evaluate a Python expression.\n--current-dir DIR     Change where the initial request will be resolved in.\n--version             Print the Node.py version and exit.\n--keep-arg0           Do not overwrite sys.argv[0] when executing a file.\n-P PRELOAD, --preload PRELOAD\n--pymain",
            "title": "Node.py v0.0.18 Documentation"
        },
        {
            "location": "/require/",
            "text": "require()\n\n\nThe \nrequire()\n function in Node.py is available for every module that is\nexecuted through the Node.py command-line or again loaded with the \nrequire()\n\nfunction. It is an instance of the \nnodepy.Require\n class and the instance is\nunique in every module.\n\n\nAPI\n\n\nrequire()\n\n\nrequire(request, current_dir=None, is_main=False, cache=True,\n         exports=True, exec_=True, into=None, symbols=None)\n\n\nResolve \nrequest\n into a module filename and load that module. For relative\npaths, the \ncurrent_dir\n will be used to resolve the request (defaults to\nthe parent directory of the module that owns the #Require instance).\n\n\nIf \nis_main\n is True, non-relative requests will also be resolved in the\n\ncurrent_dir\n first. Note that the #Context will raise a #RuntimeError when\nthere is already a #Context.main_module, thus it is recommended to use #exec_main().\n\n\nIf \ncache\n is False, the request will not be cached and also not be looked\nup into the cache.\n\n\nIf \nexports\n is False, the actual #BaseModule object is returned, otherwise\nthe #BaseModule.namespace or even #BaseModule.namespace.exports member if\nexists.\n\n\nIf \nexec_\n is False, the module will only be loaded and not be executed.\nNote that the module may have already been loaded on another occassion!\n\n\nIf \ninto\n is specified, this function behaves like a Python star-import and\nwill import all members of the module that would normally be returned into\nthe specified dictionary. Usually, you'll want to pass \nglobals()\n to this\nparameter.\n\n\nrequire.symbols()\n\n\nrequire.symbols(request, symbols=None)\n\n\nrequire.module\n\n\nrequire.main\n\n\nrequire.current\n\n\nrequire.context\n\n\nrequire.path\n\n\nrequire.cache",
            "title": "Require"
        },
        {
            "location": "/require/#require",
            "text": "The  require()  function in Node.py is available for every module that is\nexecuted through the Node.py command-line or again loaded with the  require() \nfunction. It is an instance of the  nodepy.Require  class and the instance is\nunique in every module.",
            "title": "require()"
        },
        {
            "location": "/require/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/require/#require_1",
            "text": "require(request, current_dir=None, is_main=False, cache=True,\n         exports=True, exec_=True, into=None, symbols=None)  Resolve  request  into a module filename and load that module. For relative\npaths, the  current_dir  will be used to resolve the request (defaults to\nthe parent directory of the module that owns the #Require instance).  If  is_main  is True, non-relative requests will also be resolved in the current_dir  first. Note that the #Context will raise a #RuntimeError when\nthere is already a #Context.main_module, thus it is recommended to use #exec_main().  If  cache  is False, the request will not be cached and also not be looked\nup into the cache.  If  exports  is False, the actual #BaseModule object is returned, otherwise\nthe #BaseModule.namespace or even #BaseModule.namespace.exports member if\nexists.  If  exec_  is False, the module will only be loaded and not be executed.\nNote that the module may have already been loaded on another occassion!  If  into  is specified, this function behaves like a Python star-import and\nwill import all members of the module that would normally be returned into\nthe specified dictionary. Usually, you'll want to pass  globals()  to this\nparameter.",
            "title": "require()"
        },
        {
            "location": "/require/#requiresymbols",
            "text": "require.symbols(request, symbols=None)",
            "title": "require.symbols()"
        },
        {
            "location": "/require/#requiremodule",
            "text": "",
            "title": "require.module"
        },
        {
            "location": "/require/#requiremain",
            "text": "",
            "title": "require.main"
        },
        {
            "location": "/require/#requirecurrent",
            "text": "",
            "title": "require.current"
        },
        {
            "location": "/require/#requirecontext",
            "text": "",
            "title": "require.context"
        },
        {
            "location": "/require/#requirepath",
            "text": "",
            "title": "require.path"
        },
        {
            "location": "/require/#requirecache",
            "text": "",
            "title": "require.cache"
        },
        {
            "location": "/ppym/",
            "text": "PPYM v0.0.16 Documentation\n\n\nPPYM is the \nNode.py\n package manager.",
            "title": "Home"
        },
        {
            "location": "/ppym/#ppym-v0016-documentation",
            "text": "PPYM is the  Node.py  package manager.",
            "title": "PPYM v0.0.16 Documentation"
        },
        {
            "location": "/ppym/package-manifest/",
            "text": "ppym/lib/manifest\n\n\nParse package manifests.\n\n\nmanifest\n \n=\n \nrequire\n(\n'ppym/lib/manifest'\n)\n\n\ntry\n:\n\n  \nm\n \n=\n \nmanifest\n.\nparse\n(\n'package.json'\n)\n\n\nexcept\n \n(\nFileNotFoundError\n,\n \nmanifest\n.\nInvalidPackageManifest\n)\n \nas\n \nexc\n:\n\n  \nprint\n(\nexc\n)\n\n  \nm\n \n=\n \nNone\n\n\n\n\n\n\nSpecification\n\n\nname\n\n\nRequired.\n The name of the package. This may be a scope identifier\nof the format \n@scope/package-name\n, or simply \npackage-name\n. Allowed\ncharacters for the scope and package name are digits, ASCII letters and \n-_.\n.\n\n\n{\n \n\"name\"\n:\n \n\"@ppym/manifest\"\n \n}\n\n\n\n\n\n\nversion\n\n\nRequired.\n A \nSemVer\n of the package's version.\n\n\n{\n \n\"version\"\n:\n \n\"0.0.1-security\"\n \n}\n\n\n\n\n\n\nengines\n\n\nOptional.\n An object that maps engine-names to version numbers. These version\nnumbers should be \nSemVer\n too, but that is not a requirement. The actual\nengine that runs the package will check the version number. The default engine\nis \npython\n which compares against the Python version number.\n\n\nTODO: PyPy, JPython, Stackless, etc. should match to different engine names.\n\n\n{\n\n  \n\"engines\"\n:\n \n{\n\n    \n\"python\"\n:\n \n\">=3.0.0\"\n\n  \n}\n\n\n}\n\n\n\n\n\n\nrepository\n\n\nOptional\n. URL to the source code repository where the package is developed.\nIf specified, the URL must be valid.\n\n\n{\n \n\"repository\"\n:\n \n\"https://github.com/nodepy/nodepy\"\n \n}\n\n\n\n\n\n\nlicense\n\n\nRequired when publishing a package on the registry.\n The license of the\npackage source code.\n\n\n{\n \n\"license\"\n:\n \n\"MIT\"\n \n}\n\n\n\n\n\n\nbin\n\n\nOptional.\n An object that associates script names with a request string\nthat is then executed as the main module when the script is executed.\n\n\n{\n\n  \n\"bin\"\n:\n \n{\n\n    \n\"manifest\"\n:\n \n\"cli\"\n\n  \n}\n\n\n}\n\n\n\n\n\n\nscripts\n\n\nOptional.\n An object that associates event names with Node.py modules\nwhich are executed during various events of the package lifecycle.\n\n\n{\n\n  \n\"scripts\"\n:\n \n{\n\n    \n\"post-install\"\n:\n \n\"./bin/install.py\"\n,\n\n    \n\"pre-uninstall\"\n:\n \n\"./bin/uninstall.py\"\n,\n\n    \n\"pre-dist\"\n:\n \n\"./bin/dist.py\"\n\n  \n}\n\n\n}\n\n\n\n\n\n\nCurrently supported fields are:\n\n\n\n\npre-script\n\n\npre-install, post-install\n\n\npre-uninstall\n\n\npre-dist, post-dist\n\n\npre-publish, post-publish\n\n\n\n\nTodo\n\n\n\n\npost-uninstall\n\n\npre-version, post-version\n\n\npre-test, test, post-test\n\n\npre-stop, stop, post-stop\n\n\npre-start, start, post-start\n\n\npre-restart, restart, post-restart\n\n\n\n\nprivate\n\n\nOptional\n. Prevent publication of the package with \nppym publish\n. This is used\nfor packages that want to take advantage of the PPYM dependency management but\nare not actuall supposed to be placed into the public registry. An example\nof this would be a package that generates the documentation of another project.\n\n\n{\n \n\"private\"\n:\n \ntrue\n \n}\n\n\n\n\n\n\ndependencies\n\n\nOptional.\n: An object that specifies the dependencies of the package.\nAll values must be valid \nppym/lib/semver:Selector\n syntax or Git URL syntax\nof the format \ngit+<url>[@<ref>]\n. Dependencies declared here will be installed\ntransitively.\n\n\n{\n\n  \n\"dependencies\"\n:\n \n{\n\n    \n\"ppym\"\n:\n \n\"~0.0.8\"\n,\n\n    \n\"ppym-registry\"\n:\n \n\"~0.0.3\"\n,\n\n    \n\"some-module\"\n:\n \n\"git+https://github.com/someuser/some-module.git@development\"\n\n  \n}\n\n\n}\n\n\n\n\n\n\ndev-dependencies\n\n\nOptional\n. Dependencies that are listed here are required only for developing\na package, thus they will only be installed when using \nppym install\n without\nadditional arguments in the directory where the \npackage.json\n file lives,\nunless \n--production\n is specified. Also, development dependencies will not be\ninstalled transitively.\n\n\n{\n\n  \n\"dev-dependencies\"\n:\n \n{\n\n    \n\"js-nodepy\"\n:\n \n\"~0.0.2\"\n\n  \n}\n\n\n}\n\n\n\n\n\n\npython-dependencies\n\n\nOptional.\n Similar to the \ndependencies\n field, but it specifies actual\nPython modules that the package requires. These modules can be installed\nby \nppym\n using \nPip\n.\n\n\n{\n\n  \n\"python-dependencies\"\n:\n \n{\n\n    \n\"Flask\"\n:\n \n\"==0.12\"\n,\n\n    \n\"Flask-HTTPAuth\"\n:\n \n\"==3.2.2\"\n,\n\n    \n\"mongoengine\"\n:\n \n\"==0.11.0\"\n\n  \n}\n\n\n}\n\n\n\n\n\n\ndev-python-dependencies\n\n\nOptional\n. Python dependencies that are required for developing the package.\nSee the \ndev-dependencies\n field for when development dependencies are\ninstalled.\n\n\n{\n\n  \n\"dev-python-dependencies\"\n:\n \n{\n\n    \n\"mkdocs\"\n:\n \n\">=0.16.1\"\n\n  \n}\n\n\n}\n\n\n\n\n\n\ndist\n\n\nOptional\n. An object that specifies options for generating an archived\ndistribution of the package with \nppym dist\n.\n\n\n  \n\"dist\"\n:\n \n{\n\n    \n\"include_files\"\n:\n \n[],\n\n    \n\"exclude_files\"\n:\n \n[\n\".hg*\"\n]\n\n  \n}\n\n\n\n\n\n\ninclude_files\n\n\nOptional.\n A list of patterns that match the files to include.\nMatching patterns include files possibly excluded by \nexclude_files\n.\n\n\nexclude_files\n\n\nOptional.\n A list of patterns that match the files to exclude from the\narchive. Note that when installing packages with \nppym\n, it will add\ndefault exclude patterns to this list. The actual patterns may change\nwith versions of ppym. When this document was last updated, ppym added\nthe following patterns:\n\n\n\n\n.svn/*\n\n\n.git\n\n\n.git/*\n\n\n.DS_Store\n\n\n*.pyc\n\n\n*.pyo\n\n\ndist/*\n\n\nppy_modules/\n\n\n\n\nChangelog\n\n\nv0.0.2\n\n\n\n\nAdded \nrepository\n field",
            "title": "Package manifest"
        },
        {
            "location": "/ppym/package-manifest/#ppymlibmanifest",
            "text": "Parse package manifests.  manifest   =   require ( 'ppym/lib/manifest' )  try : \n   m   =   manifest . parse ( 'package.json' )  except   ( FileNotFoundError ,   manifest . InvalidPackageManifest )   as   exc : \n   print ( exc ) \n   m   =   None",
            "title": "ppym/lib/manifest"
        },
        {
            "location": "/ppym/package-manifest/#specification",
            "text": "",
            "title": "Specification"
        },
        {
            "location": "/ppym/package-manifest/#name",
            "text": "Required.  The name of the package. This may be a scope identifier\nof the format  @scope/package-name , or simply  package-name . Allowed\ncharacters for the scope and package name are digits, ASCII letters and  -_. .  {   \"name\" :   \"@ppym/manifest\"   }",
            "title": "name"
        },
        {
            "location": "/ppym/package-manifest/#version",
            "text": "Required.  A  SemVer  of the package's version.  {   \"version\" :   \"0.0.1-security\"   }",
            "title": "version"
        },
        {
            "location": "/ppym/package-manifest/#engines",
            "text": "Optional.  An object that maps engine-names to version numbers. These version\nnumbers should be  SemVer  too, but that is not a requirement. The actual\nengine that runs the package will check the version number. The default engine\nis  python  which compares against the Python version number.  TODO: PyPy, JPython, Stackless, etc. should match to different engine names.  { \n   \"engines\" :   { \n     \"python\" :   \">=3.0.0\" \n   }  }",
            "title": "engines"
        },
        {
            "location": "/ppym/package-manifest/#repository",
            "text": "Optional . URL to the source code repository where the package is developed.\nIf specified, the URL must be valid.  {   \"repository\" :   \"https://github.com/nodepy/nodepy\"   }",
            "title": "repository"
        },
        {
            "location": "/ppym/package-manifest/#license",
            "text": "Required when publishing a package on the registry.  The license of the\npackage source code.  {   \"license\" :   \"MIT\"   }",
            "title": "license"
        },
        {
            "location": "/ppym/package-manifest/#bin",
            "text": "Optional.  An object that associates script names with a request string\nthat is then executed as the main module when the script is executed.  { \n   \"bin\" :   { \n     \"manifest\" :   \"cli\" \n   }  }",
            "title": "bin"
        },
        {
            "location": "/ppym/package-manifest/#scripts",
            "text": "Optional.  An object that associates event names with Node.py modules\nwhich are executed during various events of the package lifecycle.  { \n   \"scripts\" :   { \n     \"post-install\" :   \"./bin/install.py\" , \n     \"pre-uninstall\" :   \"./bin/uninstall.py\" , \n     \"pre-dist\" :   \"./bin/dist.py\" \n   }  }   Currently supported fields are:   pre-script  pre-install, post-install  pre-uninstall  pre-dist, post-dist  pre-publish, post-publish   Todo   post-uninstall  pre-version, post-version  pre-test, test, post-test  pre-stop, stop, post-stop  pre-start, start, post-start  pre-restart, restart, post-restart",
            "title": "scripts"
        },
        {
            "location": "/ppym/package-manifest/#private",
            "text": "Optional . Prevent publication of the package with  ppym publish . This is used\nfor packages that want to take advantage of the PPYM dependency management but\nare not actuall supposed to be placed into the public registry. An example\nof this would be a package that generates the documentation of another project.  {   \"private\" :   true   }",
            "title": "private"
        },
        {
            "location": "/ppym/package-manifest/#dependencies",
            "text": "Optional. : An object that specifies the dependencies of the package.\nAll values must be valid  ppym/lib/semver:Selector  syntax or Git URL syntax\nof the format  git+<url>[@<ref>] . Dependencies declared here will be installed\ntransitively.  { \n   \"dependencies\" :   { \n     \"ppym\" :   \"~0.0.8\" , \n     \"ppym-registry\" :   \"~0.0.3\" , \n     \"some-module\" :   \"git+https://github.com/someuser/some-module.git@development\" \n   }  }",
            "title": "dependencies"
        },
        {
            "location": "/ppym/package-manifest/#dev-dependencies",
            "text": "Optional . Dependencies that are listed here are required only for developing\na package, thus they will only be installed when using  ppym install  without\nadditional arguments in the directory where the  package.json  file lives,\nunless  --production  is specified. Also, development dependencies will not be\ninstalled transitively.  { \n   \"dev-dependencies\" :   { \n     \"js-nodepy\" :   \"~0.0.2\" \n   }  }",
            "title": "dev-dependencies"
        },
        {
            "location": "/ppym/package-manifest/#python-dependencies",
            "text": "Optional.  Similar to the  dependencies  field, but it specifies actual\nPython modules that the package requires. These modules can be installed\nby  ppym  using  Pip .  { \n   \"python-dependencies\" :   { \n     \"Flask\" :   \"==0.12\" , \n     \"Flask-HTTPAuth\" :   \"==3.2.2\" , \n     \"mongoengine\" :   \"==0.11.0\" \n   }  }",
            "title": "python-dependencies"
        },
        {
            "location": "/ppym/package-manifest/#dev-python-dependencies",
            "text": "Optional . Python dependencies that are required for developing the package.\nSee the  dev-dependencies  field for when development dependencies are\ninstalled.  { \n   \"dev-python-dependencies\" :   { \n     \"mkdocs\" :   \">=0.16.1\" \n   }  }",
            "title": "dev-python-dependencies"
        },
        {
            "location": "/ppym/package-manifest/#dist",
            "text": "Optional . An object that specifies options for generating an archived\ndistribution of the package with  ppym dist .     \"dist\" :   { \n     \"include_files\" :   [], \n     \"exclude_files\" :   [ \".hg*\" ] \n   }",
            "title": "dist"
        },
        {
            "location": "/ppym/package-manifest/#include_files",
            "text": "Optional.  A list of patterns that match the files to include.\nMatching patterns include files possibly excluded by  exclude_files .",
            "title": "include_files"
        },
        {
            "location": "/ppym/package-manifest/#exclude_files",
            "text": "Optional.  A list of patterns that match the files to exclude from the\narchive. Note that when installing packages with  ppym , it will add\ndefault exclude patterns to this list. The actual patterns may change\nwith versions of ppym. When this document was last updated, ppym added\nthe following patterns:   .svn/*  .git  .git/*  .DS_Store  *.pyc  *.pyo  dist/*  ppy_modules/",
            "title": "exclude_files"
        },
        {
            "location": "/ppym/package-manifest/#changelog",
            "text": "",
            "title": "Changelog"
        },
        {
            "location": "/ppym/package-manifest/#v002",
            "text": "Added  repository  field",
            "title": "v0.0.2"
        },
        {
            "location": "/ppym/commands/bin/",
            "text": "bin\n\n\nppym bin [--global] [--pip]\n\n\n\n\n\nPrints the local or global binary directory that PPYM installs to. If you\npass the \n--pip\n switch, the Pip binary directory will be printed instead.\n\n\nNote that \nppym install\n will automatically create wrappers in\nthe Node.py binary directory that reference respective commands in the Pip\nbinary directory, thus if you have Python dependencies that expose scripts,\nyou only need to add the Node.py binary directory to your path.\n\n\nThe local binary directory is \nnodepy_modules/.bin\n.",
            "title": "Bin"
        },
        {
            "location": "/ppym/commands/bin/#bin",
            "text": "ppym bin [--global] [--pip]  Prints the local or global binary directory that PPYM installs to. If you\npass the  --pip  switch, the Pip binary directory will be printed instead.  Note that  ppym install  will automatically create wrappers in\nthe Node.py binary directory that reference respective commands in the Pip\nbinary directory, thus if you have Python dependencies that expose scripts,\nyou only need to add the Node.py binary directory to your path.  The local binary directory is  nodepy_modules/.bin .",
            "title": "bin"
        },
        {
            "location": "/ppym/commands/dist/",
            "text": "dist\n\n\nppym dist\n\n\n\n\n\nCreate a \n.tar.gz\n archive from your package and save it into the \ndist/\n\ndirectory. If you want to publish the package on the registry, use the\n\nppym publish\n command.",
            "title": "Dist"
        },
        {
            "location": "/ppym/commands/dist/#dist",
            "text": "ppym dist  Create a  .tar.gz  archive from your package and save it into the  dist/ \ndirectory. If you want to publish the package on the registry, use the ppym publish  command.",
            "title": "dist"
        },
        {
            "location": "/ppym/commands/init/",
            "text": "init\n\n\nppym init\n\n\n\n\n\nInitialize a \npackage.json\n file in the current working directory.",
            "title": "Init"
        },
        {
            "location": "/ppym/commands/init/#init",
            "text": "ppym init  Initialize a  package.json  file in the current working directory.",
            "title": "init"
        },
        {
            "location": "/ppym/commands/install/",
            "text": "install\n\n\nppym install [-g,--global] [--root] [-e,--develop] [--pip-separate-process]\n             [--dev/--production] [--save] [--save-dev] [--recursive]\n             [PACKAGES]\n\n\n\n\n\nInstalls one or more Node.py packages from the PPYM registry, package\ndistribution files (see \nppym dist\n) or a directory. If no PACKAGES\nare specified, the dependencies of the current package are installed. In that\ncase, the \n--dev\n switch is enabled by default, otherwise \n--production\n is\nthe default.\n\n\nThe \nPACKAGES\n argument, if specified, can be of the following type:\n\n\n\n\nA package name and version selector of the format \n<package>[@<version>]\n,\n  in which case the package will be looked up and installed from the PPYM\n  registry.\n\n\nAn existing directory that contains a \npackage.json\n to install from.\n\n\nA Git URL in the format \ngit+<url>[@<ref>]\n to install the package from.\n\n\n\n\nWith \n--dev\n enabled, the development dependencies of the packages are\ninstalled additionally to their normal runtime dependencies. Note that\ndevelopment dependencies are never installed transitively.\n\n\nUsing \n--global\n will install the PACKAGES into the user-global modules directory\nand creates scripts in the global binaries directory. Note that \"global\" always\nrefers to the \"User-space global\". Global installations are only supposed to\nbe used for command-line tools. Node.py will not look to resolve \nrequire()\ns\nin the global modules directory for your local project.\n\n\nThe \n--root\n option will install the package into the global Python prefix and\nshould only be used when a command-line utility should be installed for all\nusers of a system.\n\n\n\n\nNote: Inside a virtual environment, \n-g,--global\n will be promoted to \n--root\n.\n\n\n\n\nThe \n--develop\n flag can only be used when installing a package from a\ndirectory. Using this flag will install the package in development mode, which\nmeans that a \n.nodepy-link\n file will be created instead of the package\ncontents being copied. Node.py will read this link and continue resolving\n\nrequire()\ns in the target directory (which is your package that you installed\nwith \n--develop\n).\n\n\nUsing the \n--save\n or \n--save-dev\n options requires a \npackage.json\n in the\ncurrent working directory to which the new dependencies can be added. Note\nalso that the package manifest will be re-written with a strict 2-space\nindentation.\n\n\nThe \n--recursive\n option can be used to make sure dependencies of already\nsatisfied dependencies are satisfied as well. This can be useful if you\nuninstall a dependencies of another package and want to re-install them\nwithout remembering them all.",
            "title": "Install"
        },
        {
            "location": "/ppym/commands/install/#install",
            "text": "ppym install [-g,--global] [--root] [-e,--develop] [--pip-separate-process]\n             [--dev/--production] [--save] [--save-dev] [--recursive]\n             [PACKAGES]  Installs one or more Node.py packages from the PPYM registry, package\ndistribution files (see  ppym dist ) or a directory. If no PACKAGES\nare specified, the dependencies of the current package are installed. In that\ncase, the  --dev  switch is enabled by default, otherwise  --production  is\nthe default.  The  PACKAGES  argument, if specified, can be of the following type:   A package name and version selector of the format  <package>[@<version>] ,\n  in which case the package will be looked up and installed from the PPYM\n  registry.  An existing directory that contains a  package.json  to install from.  A Git URL in the format  git+<url>[@<ref>]  to install the package from.   With  --dev  enabled, the development dependencies of the packages are\ninstalled additionally to their normal runtime dependencies. Note that\ndevelopment dependencies are never installed transitively.  Using  --global  will install the PACKAGES into the user-global modules directory\nand creates scripts in the global binaries directory. Note that \"global\" always\nrefers to the \"User-space global\". Global installations are only supposed to\nbe used for command-line tools. Node.py will not look to resolve  require() s\nin the global modules directory for your local project.  The  --root  option will install the package into the global Python prefix and\nshould only be used when a command-line utility should be installed for all\nusers of a system.   Note: Inside a virtual environment,  -g,--global  will be promoted to  --root .   The  --develop  flag can only be used when installing a package from a\ndirectory. Using this flag will install the package in development mode, which\nmeans that a  .nodepy-link  file will be created instead of the package\ncontents being copied. Node.py will read this link and continue resolving require() s in the target directory (which is your package that you installed\nwith  --develop ).  Using the  --save  or  --save-dev  options requires a  package.json  in the\ncurrent working directory to which the new dependencies can be added. Note\nalso that the package manifest will be re-written with a strict 2-space\nindentation.  The  --recursive  option can be used to make sure dependencies of already\nsatisfied dependencies are satisfied as well. This can be useful if you\nuninstall a dependencies of another package and want to re-install them\nwithout remembering them all.",
            "title": "install"
        },
        {
            "location": "/ppym/commands/pip-install/",
            "text": "pip-install [-g,--global] [--root] ARGS\n\n\n\n\n\nRuns Pip's \ninstall\n sub-command with the specified ARGS. The \n--prefix\n option\nwill be passed automatically and correctly depending on whether -g,--global or\n--root is specified or not specified.",
            "title": "Pip install"
        },
        {
            "location": "/ppym/commands/publish/",
            "text": "publish\n\n\nppym publish [-f,--force] [-u,--user] [-p,--password]\n\n\n\n\n\nA combination of \nppym dist\n and \nppym upload\n that also\ninvokes the \npre-publish\n and \npost-publish\n \nscripts\n.\n\n\nRequirements\n\n\nIn order to publish a package to \nppym.org\n, it must\nmeet the following requirements:\n\n\n\n\nThe \nname\n of the package must be scoped with your username (ie. \n@username/packagename\n)\n\n\nThe \nlicense\n field in \npackage.json\n must not be empty\n\n\n\n\nAfter a package version has been uploaded to the registry, arbitrary files\nmay be uploaded to that version as well. This is intended to be used for\nadditional files that may be downloaded by the actual package when necessary.\nNote that https://ppym.org currently has a size upload limit of 2MiB.\n\n\nIt is important that you read and understand the \nPPYM Registry Terms of Use\n\nbefore you publish packages and upload content to the registry.",
            "title": "Publish"
        },
        {
            "location": "/ppym/commands/publish/#publish",
            "text": "ppym publish [-f,--force] [-u,--user] [-p,--password]  A combination of  ppym dist  and  ppym upload  that also\ninvokes the  pre-publish  and  post-publish   scripts .",
            "title": "publish"
        },
        {
            "location": "/ppym/commands/publish/#requirements",
            "text": "In order to publish a package to  ppym.org , it must\nmeet the following requirements:   The  name  of the package must be scoped with your username (ie.  @username/packagename )  The  license  field in  package.json  must not be empty   After a package version has been uploaded to the registry, arbitrary files\nmay be uploaded to that version as well. This is intended to be used for\nadditional files that may be downloaded by the actual package when necessary.\nNote that https://ppym.org currently has a size upload limit of 2MiB.  It is important that you read and understand the  PPYM Registry Terms of Use \nbefore you publish packages and upload content to the registry.",
            "title": "Requirements"
        },
        {
            "location": "/ppym/commands/register/",
            "text": "register\n\n\nppym register [--agree-tos] [--save]\n\n\n\n\n\nRegister a new account on the PPYM registry. Note that you can change the\nURL to the registry being used in the \n~/.ppymrc\n file. By default, it will\npoint to https://ppym.org.\n\n\n$ craftr ~/.ppymrc\n\nregistry\n=\nhttp://localhost:8000",
            "title": "Register"
        },
        {
            "location": "/ppym/commands/register/#register",
            "text": "ppym register [--agree-tos] [--save]  Register a new account on the PPYM registry. Note that you can change the\nURL to the registry being used in the  ~/.ppymrc  file. By default, it will\npoint to https://ppym.org.  $ craftr ~/.ppymrc registry = http://localhost:8000",
            "title": "register"
        },
        {
            "location": "/ppym/commands/run/",
            "text": "run\n\n\nppym run SCRIPT [ARGS]\n\n\n\n\n\nRuns the SCRIPT that is specified in the current package's manifest. Note that\nsome scripts have special meanings and will be invoked automatically by other\nprocedures of PPYM.\n\n\nExample\n\n\n{\n\n  \n\"scripts\"\n:\n \n{\n\n    \n\"build-docs\"\n:\n \n\"!mkdocs build\"\n,\n\n    \n\"pre-publish\"\n:\n \n\"scripts/pre-publish.py\"\n\n  \n}\n\n\n}\n\n\n\n\n\n\n$ ppym run build-docs",
            "title": "Run"
        },
        {
            "location": "/ppym/commands/run/#run",
            "text": "ppym run SCRIPT [ARGS]  Runs the SCRIPT that is specified in the current package's manifest. Note that\nsome scripts have special meanings and will be invoked automatically by other\nprocedures of PPYM.",
            "title": "run"
        },
        {
            "location": "/ppym/commands/run/#example",
            "text": "{ \n   \"scripts\" :   { \n     \"build-docs\" :   \"!mkdocs build\" , \n     \"pre-publish\" :   \"scripts/pre-publish.py\" \n   }  }   $ ppym run build-docs",
            "title": "Example"
        },
        {
            "location": "/ppym/commands/uninstall/",
            "text": "uninstall\n\n\nppym uninstall [-g,--global] PACKAGES\n\n\n\n\n\nUninstalls one or more previously installed PACKAGES.",
            "title": "Uninstall"
        },
        {
            "location": "/ppym/commands/uninstall/#uninstall",
            "text": "ppym uninstall [-g,--global] PACKAGES  Uninstalls one or more previously installed PACKAGES.",
            "title": "uninstall"
        },
        {
            "location": "/ppym/commands/upload/",
            "text": "upload\n\n\nppym upload [-f, --force] [-u, --user] [-p, --password] FILENAME\n\n\n\n\n\nFor the current version that is specified in the \npackage.json\n of your\nproject, uploads the specified FILENAME to the package registry. If the\nversion and/or package does not exist at the time of the upload, the file\nwill be rejected unless you upload the distribution archive created with\n\nppym dist\n first. If you upload the distribution archive, the\npackage and package version will be created and assigned to your account.\n\n\n\n\nNote\n: You should prefer to use the \nppym publish\n command\nto publish your package as it is less error prone and will also invoke\nthe \npre-publish\n script if you have one specified in your package manifest.\n\n\n\n\nRead about the \nRequirements\n to publish a package.",
            "title": "Upload"
        },
        {
            "location": "/ppym/commands/upload/#upload",
            "text": "ppym upload [-f, --force] [-u, --user] [-p, --password] FILENAME  For the current version that is specified in the  package.json  of your\nproject, uploads the specified FILENAME to the package registry. If the\nversion and/or package does not exist at the time of the upload, the file\nwill be rejected unless you upload the distribution archive created with ppym dist  first. If you upload the distribution archive, the\npackage and package version will be created and assigned to your account.   Note : You should prefer to use the  ppym publish  command\nto publish your package as it is less error prone and will also invoke\nthe  pre-publish  script if you have one specified in your package manifest.   Read about the  Requirements  to publish a package.",
            "title": "upload"
        }
    ]
}